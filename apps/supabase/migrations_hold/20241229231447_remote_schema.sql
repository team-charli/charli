

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."request_origin_enum" AS ENUM (
    'learner',
    'teacher'
);


ALTER TYPE "public"."request_origin_enum" OWNER TO "postgres";


CREATE TYPE "public"."session_req_reject_reason" AS ENUM (
    'no_time',
    'no_interest',
    'other'
);


ALTER TYPE "public"."session_req_reject_reason" OWNER TO "postgres";


COMMENT ON TYPE "public"."session_req_reject_reason" IS 'list potential reasons a user rejects a session request';



CREATE OR REPLACE FUNCTION "public"."check_wants_to_learn_langs"("langs" integer[]) RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN NOT EXISTS (
    SELECT 1
    FROM unnest(langs) AS lang
    WHERE lang NOT IN (SELECT id FROM languages)
  );
END;
$$;


ALTER FUNCTION "public"."check_wants_to_learn_langs"("langs" integer[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_wants_to_teach_langs"("langs" integer[]) RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN NOT EXISTS (
    SELECT 1
    FROM unnest(langs) AS lang
    WHERE lang NOT IN (SELECT id FROM languages)
  );
END;
$$;


ALTER FUNCTION "public"."check_wants_to_teach_langs"("langs" integer[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_eth_address_from_jwt"() RETURNS "text"
    LANGUAGE "sql" STABLE
    AS $$
  -- This function would ideally extract the Ethereum address from the JWT's subject (sub) claim
  -- Placeholder for actual implementation
  SELECT current_setting('request.jwt.claim.sub', true)::text;
$$;


ALTER FUNCTION "public"."get_eth_address_from_jwt"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."user_data" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "wants_to_teach_langs" integer[],
    "wants_to_learn_langs" integer[],
    "user_address" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "default_native_language" "text" NOT NULL,
    "auth_provider_id" "text",
    CONSTRAINT "chk_wants_to_learn_langs" CHECK ("public"."check_wants_to_learn_langs"("wants_to_learn_langs")),
    CONSTRAINT "chk_wants_to_teach_langs" CHECK ("public"."check_wants_to_teach_langs"("wants_to_teach_langs"))
);


ALTER TABLE "public"."user_data" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_data" IS 'Language Preferences and Personal Data';



ALTER TABLE "public"."user_data" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."User_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."language_interest" (
    "id" integer NOT NULL,
    "language_id" integer NOT NULL,
    "user_id" bigint NOT NULL,
    "interest_type" character varying(10),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "language_interest_interest_type_check" CHECK ((("interest_type")::"text" = ANY (ARRAY[('teach'::character varying)::"text", ('learn'::character varying)::"text"])))
);


ALTER TABLE "public"."language_interest" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."language_interest_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."language_interest_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."language_interest_id_seq" OWNED BY "public"."language_interest"."id";



CREATE TABLE IF NOT EXISTS "public"."languages" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "language_code" "text" NOT NULL,
    "country_code" "text",
    "emoji" "text"
);


ALTER TABLE "public"."languages" OWNER TO "postgres";


COMMENT ON COLUMN "public"."languages"."language_code" IS 'ISO 639-2';



COMMENT ON COLUMN "public"."languages"."country_code" IS 'ISO 3166-1 alpha-2';



CREATE SEQUENCE IF NOT EXISTS "public"."languages_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."languages_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."languages_id_seq" OWNED BY "public"."languages"."id";



CREATE TABLE IF NOT EXISTS "public"."sessions" (
    "session_id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "request_time_date" timestamp without time zone,
    "counter_time_date" timestamp without time zone,
    "confirmed_time_date" timestamp without time zone,
    "huddle_room_id" "text",
    "teacher_id" bigint,
    "learner_id" bigint,
    "request_origin_type" "public"."request_origin_enum" NOT NULL,
    "session_rejected_reason" "public"."session_req_reject_reason",
    "request_origin" bigint,
    "teaching_lang" "text",
    "controller_address" "text",
    "requested_session_duration" smallint,
    "controller_public_key" "text",
    "hashed_learner_address" "text",
    "hashed_teacher_address" "text",
    "session_resolved" boolean,
    "ipfs_cid_learner" "text",
    "ipfs_cid_teacher" "text",
    "initial_signed_duration_ipfs_cid" "text",
    "countersignature_duration_ipfs_cid" "text",
    "requested_session_duration_learner_sig" "text",
    "requested_session_duration_teacher_sig" "text",
    "secure_session_id" "text",
    "key_claim_data" "jsonb" NOT NULL,
    "learner_address_encrypt_hash" "text",
    "learner_address_cipher_text" "text"
);


ALTER TABLE "public"."sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."sessions" IS 'session data';



COMMENT ON COLUMN "public"."sessions"."request_origin_type" IS 'user type who made the session request';



COMMENT ON COLUMN "public"."sessions"."session_rejected_reason" IS 'if session request rejected, enum of reasons ';



COMMENT ON COLUMN "public"."sessions"."request_origin" IS 'user id who made the request';



COMMENT ON COLUMN "public"."sessions"."requested_session_duration" IS 'minutes';



COMMENT ON COLUMN "public"."sessions"."ipfs_cid_learner" IS 'ipfs_cid of a session';



COMMENT ON COLUMN "public"."sessions"."secure_session_id" IS 'unique identify generated on session request to help secure the Lit Actions';



COMMENT ON COLUMN "public"."sessions"."learner_address_encrypt_hash" IS 'used to decrypt learner address in transferFrom lit action';



COMMENT ON COLUMN "public"."sessions"."learner_address_cipher_text" IS 'used to for decrypting learner address in transferFrom lit action';



ALTER TABLE "public"."sessions" ALTER COLUMN "session_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."sessions_session_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."language_interest" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."language_interest_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."languages" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."languages_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "User_NAME_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."language_interest"
    ADD CONSTRAINT "language_interest_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."languages"
    ADD CONSTRAINT "languages_language_code_country_code_key" UNIQUE ("language_code", "country_code");



ALTER TABLE ONLY "public"."languages"
    ADD CONSTRAINT "languages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sessions"
    ADD CONSTRAINT "sessions_pkey" PRIMARY KEY ("session_id");



ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "user_address_unique" UNIQUE ("user_address");



ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "user_data_auth_provider_id_key" UNIQUE ("auth_provider_id");



ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "user_data_pkey" PRIMARY KEY ("id");



CREATE OR REPLACE TRIGGER "create_huddle_room" AFTER UPDATE OF "confirmed_time_date" ON "public"."sessions" FOR EACH ROW WHEN (("old"."confirmed_time_date" IS DISTINCT FROM "new"."confirmed_time_date")) EXECUTE FUNCTION "supabase_functions"."http_request"('https://onhlhmondvxwwiwnruvo.supabase.co/functions/v1/create-huddle-room', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9uaGxobW9uZHZ4d3dpd25ydXZvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY5NzQ4ODU4NSwiZXhwIjoyMDEzMDY0NTg1fQ.UvvYsR8dPcA331nbjZavckGz4Rkab6haU2RcNok9q1Q"}', '{"update_confirmed_time_date":"NEW.confirmed_time_date::text"}', '1000');



ALTER TABLE ONLY "public"."language_interest"
    ADD CONSTRAINT "fk_language" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id");



ALTER TABLE ONLY "public"."sessions"
    ADD CONSTRAINT "fk_sessions_learner_id" FOREIGN KEY ("learner_id") REFERENCES "public"."user_data"("id");



ALTER TABLE ONLY "public"."sessions"
    ADD CONSTRAINT "fk_sessions_teacher_id" FOREIGN KEY ("teacher_id") REFERENCES "public"."user_data"("id");



ALTER TABLE ONLY "public"."language_interest"
    ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "public"."user_data"("id");



ALTER TABLE ONLY "public"."sessions"
    ADD CONSTRAINT "public_sessions_request_origin_fkey" FOREIGN KEY ("request_origin") REFERENCES "public"."user_data"("id");



CREATE POLICY "User can insert own data" ON "public"."languages" FOR INSERT WITH CHECK (true);



CREATE POLICY "User can insert own data" ON "public"."user_data" FOR INSERT WITH CHECK ((("auth"."uid"())::"text" = "auth_provider_id"));



CREATE POLICY "User can update own data" ON "public"."languages" FOR UPDATE USING (true) WITH CHECK (true);



CREATE POLICY "User can update own data" ON "public"."user_data" FOR UPDATE USING ((("auth"."uid"())::"text" = "auth_provider_id")) WITH CHECK ((("auth"."uid"())::"text" = "auth_provider_id"));



CREATE POLICY "allow_all_reads" ON "public"."languages" FOR SELECT USING (true);



CREATE POLICY "allow_all_reads" ON "public"."user_data" FOR SELECT USING (true);



CREATE POLICY "insert_sessions" ON "public"."sessions" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_data"
  WHERE (("user_data"."auth_provider_id" = ("auth"."uid"())::"text") AND (("user_data"."id" = "sessions"."learner_id") OR ("user_data"."id" = "sessions"."teacher_id"))))));



ALTER TABLE "public"."languages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "read_languages" ON "public"."languages" FOR SELECT USING (true);



CREATE POLICY "read_sessions" ON "public"."sessions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_data"
  WHERE (("user_data"."auth_provider_id" = ("auth"."uid"())::"text") AND (("user_data"."id" = "sessions"."learner_id") OR ("user_data"."id" = "sessions"."teacher_id"))))));



CREATE POLICY "restrict_writes_languages" ON "public"."languages" USING (false);



ALTER TABLE "public"."sessions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "update_sessions" ON "public"."sessions" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_data"
  WHERE (("user_data"."auth_provider_id" = ("auth"."uid"())::"text") AND (("user_data"."id" = "sessions"."learner_id") OR ("user_data"."id" = "sessions"."teacher_id")))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_data"
  WHERE (("user_data"."auth_provider_id" = ("auth"."uid"())::"text") AND (("user_data"."id" = "sessions"."learner_id") OR ("user_data"."id" = "sessions"."teacher_id"))))));



ALTER TABLE "public"."user_data" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."sessions";






REVOKE USAGE ON SCHEMA "public" FROM PUBLIC;
GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



































































































































































































GRANT ALL ON FUNCTION "public"."check_wants_to_learn_langs"("langs" integer[]) TO "anon";
GRANT ALL ON FUNCTION "public"."check_wants_to_learn_langs"("langs" integer[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_wants_to_learn_langs"("langs" integer[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."check_wants_to_teach_langs"("langs" integer[]) TO "anon";
GRANT ALL ON FUNCTION "public"."check_wants_to_teach_langs"("langs" integer[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_wants_to_teach_langs"("langs" integer[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_eth_address_from_jwt"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_eth_address_from_jwt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_eth_address_from_jwt"() TO "service_role";





















GRANT ALL ON TABLE "public"."user_data" TO "anon";
GRANT ALL ON TABLE "public"."user_data" TO "authenticated";
GRANT ALL ON TABLE "public"."user_data" TO "service_role";
GRANT SELECT ON TABLE "public"."user_data" TO PUBLIC;



GRANT ALL ON SEQUENCE "public"."User_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."User_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."User_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."language_interest" TO "anon";
GRANT ALL ON TABLE "public"."language_interest" TO "authenticated";
GRANT ALL ON TABLE "public"."language_interest" TO "service_role";



GRANT ALL ON SEQUENCE "public"."language_interest_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."language_interest_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."language_interest_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."languages" TO "anon";
GRANT ALL ON TABLE "public"."languages" TO "authenticated";
GRANT ALL ON TABLE "public"."languages" TO "service_role";



GRANT ALL ON SEQUENCE "public"."languages_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."languages_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."languages_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."sessions" TO "anon";
GRANT ALL ON TABLE "public"."sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."sessions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."sessions_session_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."sessions_session_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."sessions_session_id_seq" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;
